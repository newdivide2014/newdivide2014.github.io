[{"content":"问题描述 发布的qt程序在多屏幕机器上显示不全。\n反复调试了好久，发现在只有一块显示屏中程序显示正常。但是在同事的外接了一块显示屏下运行程序时，程序总是不在屏幕中间，而是只显示了一半，每次启动程序位置都是有一半不在屏幕内，还需要拖动。对于用户的使用不友好\u0026hellip;\n原始测试代码段：\n1 2 3 4 5 6 7 8  int main(int argc, char *argv[]) { QApplication a(argc, argv); MainWidget w; w.move((a.desktop()-\u0026gt;width()-w.width())/2,((a.desktop()-\u0026gt;height()-w.height())/2)); w.show(); return a.exec(); }    帮助文档内容： However, for desktops with multiple screens, the size of the desktop is the union of all the screen sizes, so width() and height() should not be used for computing the size of a widget to be placed on one of the screens.\n 原来这位置是用像素大小来计算的，单屏幕上也并没有什么问题，但是在多屏下就有问题了，因为多屏下的像素是所有屏幕加起来，所以用上面的方法，程序界面位置是不可预料。\n解决办法 1 2 3 4 5 6 7 8 9 10 11 12 13  int main(int argc, char *argv[]) { QApplication a(argc, argv); MainWidget w; //程序所在的屏幕编号  int currentScreen = a.desktop()-\u0026gt;screenNumber(\u0026amp;w); //程序所在屏幕尺寸  QRect rect = a.desktop()-\u0026gt;screenGeometry(currentScreen); //移动到所在屏幕中间  w.move((rect.width() - w.width()) / 2, (rect.height() - w.height()) / 2); w.show(); return a.exec(); }   ","permalink":"https://newdivide2014.github.io/zh-cn/posts/qt-ui-center-show/","summary":"\u003ch3 id=\"问题描述\"\u003e问题描述\u003c/h3\u003e\n\u003cp\u003e发布的qt程序在多屏幕机器上显示不全。\u003c/p\u003e","title":"qt程序在多屏下显示不全的问题"},{"content":"献上狗子~嘻嘻\n将 /etc/ 内的所有档案备份下来，并且保存其权限！\n[root@linux ~]# tar -czvpf /tmp/etc.tar.gz /etc  这个-p的属性是很重要的，尤其是当您要保留原本档案的属性时！\n","permalink":"https://newdivide2014.github.io/zh-cn/posts/linux-tar-cmd/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/post/DSC_0803.JPG\" alt=\"dog\"  /\u003e\n\u003c/p\u003e","title":"Linux tar备忘"},{"content":"RS485和RS232 RS232标准诞生于RS485之前，但RS232有几处不足的地方：\n  接口的信号电平值较高，达到时机伏，使用不当容易损坏接口芯片，电平标准也与TTL电平不兼容。\n  传输速率有局限，不可以过高，一般到一两百千比特每秒（Kb/s）就到极限了。\n  接口使用信号线和GND与其他设备形成共地模式的通信，这种共地模式传输容易产生干扰，并且抗干扰能力比较弱。\n  传输距离有限，最多只能通信几十米。\n  通信的时候只能两点之间进行通信，不能够实现多机制联网通信。 针对RS232接口的不足，就不断出现了一些新的接口标准，RS485就是其中之一，它具备以下特点：\n  采用差分信号。差分最大的好处就是可以抑制共模干扰。尤其当工业现场环境比较复杂，干扰比较多是，采用差分方式可以有效的提高通信可靠性。RS485 采用两根通信线，通常用 A 和 B 或者 D+和 D-来表示。逻辑“1”以两线之间的电压差为+(0.2~6)V 表示，逻辑“0”以两线间的电压差为-(0.2~6)V 来表示，是一种典型的差分通信。\n  RS485通信速率快，最大传输速度可达10Mb/s。\n  RS485内部的物理结构，采用的平衡驱动器和差分接收器的组合，抗干扰能力也大大增强。\n  传输距离最远可以达到1200米左右，但它的传输速率和传输距离成反比。只有在 100Kb/s 以下的传输速度，才能达到最大的通信距离，如果需要传输更远距离可以使用中继。\n  可以在总线上进行联网实现多机通信，总线上允许挂多个收发器，从现有的 RS485芯片来看，有可以挂 32、64、128、256 等不同个设备的驱动器。\n  RS485 的接口非常简单，与 RS232 所使用的 MAX232 是类似的，只需要一个 RS485转换器，就可以直接与单片机的 UART 串口连接起来，并且使用完全相同的异步串行通信协议。但是由于 RS485 是差分通信，因此接收数据和发送数据是不能同时进行的，也就是说它是一种半双工通信。\n  RS485是一个物理接口，简单的说是硬件。 MODBUS是一种国际标准的通讯协议，用于不同厂商之间的设备交换数据（一般是工业用途）；\nModbus简单了解 一般情况下，两台设备通过MODBUS协议传输数据： 最早是用RS232C作为硬件接口，（也就是普通电脑上的串行通讯口（串口））； 也有用RS422的， 也有常用的RS485，这种接口传输距离远，在一般工业现场用的比较多。\nMODBUS协议又分MODBUS RTU，MODBUS ASCII和后来发展的MODBUS TCP三种模式： 其中前两种（MODBUS RTU，MODBUS ASCII）所用的物理硬件接口都是串行（Serial）通讯口（RS232，RS422，RS485）。 而MODBUS TCP则是为了顺应当今世界发展潮流，什么都可以用Ethernet网或Internet来连接，传送数据。所以又MODBUS TCP模式，该模式的硬件接口就是以太网（Ethernet）口了，也就是我们电脑上一般用的网络口了。\n","permalink":"https://newdivide2014.github.io/zh-cn/posts/rs485-rs232/","summary":"RS485和RS232 RS232标准诞生于RS485之前，但RS232有几处不足的地方：\n  接口的信号电平值较高，达到时机伏，使用不当容易损坏接口芯片，电平标准也与TTL电平不兼容。\n  传输速率有局限，不可以过高，一般到一两百千比特每秒（Kb/s）就到极限了。\n  接口使用信号线和GND与其他设备形成共地模式的通信，这种共地模式传输容易产生干扰，并且抗干扰能力比较弱。\n  传输距离有限，最多只能通信几十米。\n  通信的时候只能两点之间进行通信，不能够实现多机制联网通信。 针对RS232接口的不足，就不断出现了一些新的接口标准，RS485就是其中之一，它具备以下特点：\n  采用差分信号。差分最大的好处就是可以抑制共模干扰。尤其当工业现场环境比较复杂，干扰比较多是，采用差分方式可以有效的提高通信可靠性。RS485 采用两根通信线，通常用 A 和 B 或者 D+和 D-来表示。逻辑“1”以两线之间的电压差为+(0.2~6)V 表示，逻辑“0”以两线间的电压差为-(0.2~6)V 来表示，是一种典型的差分通信。\n  RS485通信速率快，最大传输速度可达10Mb/s。\n  RS485内部的物理结构，采用的平衡驱动器和差分接收器的组合，抗干扰能力也大大增强。\n  传输距离最远可以达到1200米左右，但它的传输速率和传输距离成反比。只有在 100Kb/s 以下的传输速度，才能达到最大的通信距离，如果需要传输更远距离可以使用中继。\n  可以在总线上进行联网实现多机通信，总线上允许挂多个收发器，从现有的 RS485芯片来看，有可以挂 32、64、128、256 等不同个设备的驱动器。\n  RS485 的接口非常简单，与 RS232 所使用的 MAX232 是类似的，只需要一个 RS485转换器，就可以直接与单片机的 UART 串口连接起来，并且使用完全相同的异步串行通信协议。但是由于 RS485 是差分通信，因此接收数据和发送数据是不能同时进行的，也就是说它是一种半双工通信。\n  RS485是一个物理接口，简单的说是硬件。 MODBUS是一种国际标准的通讯协议，用于不同厂商之间的设备交换数据（一般是工业用途）；\nModbus简单了解 一般情况下，两台设备通过MODBUS协议传输数据： 最早是用RS232C作为硬件接口，（也就是普通电脑上的串行通讯口（串口））； 也有用RS422的， 也有常用的RS485，这种接口传输距离远，在一般工业现场用的比较多。\nMODBUS协议又分MODBUS RTU，MODBUS ASCII和后来发展的MODBUS TCP三种模式： 其中前两种（MODBUS RTU，MODBUS ASCII）所用的物理硬件接口都是串行（Serial）通讯口（RS232，RS422，RS485）。 而MODBUS TCP则是为了顺应当今世界发展潮流，什么都可以用Ethernet网或Internet来连接，传送数据。所以又MODBUS TCP模式，该模式的硬件接口就是以太网（Ethernet）口了，也就是我们电脑上一般用的网络口了。","title":"RS485和RS232区别"},{"content":"记录一些常用的git命令，忘记的时候来翻翻看。\ngit常用命令   查看当前git用户的配置\n git config --list    配置用户信息\n git config --global user.name \u0026quot;xxx\u0026quot; git config --global user.email \u0026quot;xxx@xxx\u0026quot;    开始新的项目，初始化新的仓库\n git init    把文件/目录加入暂存区（stage）例子是把当前目录下的所有文件加入到暂存区。\n git add .    把文件或目录从暂存区（stage）移除 git rm \u0026ndash;cached ./demo.txt 此刻./demo.txt文件已经从暂存区域删除，但是仍在当前目录下，如果想把该文件也从工作目录中删除，执行\n git rm ./demo.txt    git提交忽略某些文件 有些不需要git管理的文件比如.o文件等，可以在跟目录下创建一个名为**.gitignore**，然后在此文件里添加：\n *.o    所有空行或#开头的行都会被忽略，以上的设置在每次提交是就会忽略所有的.o文件。\n 修改最后一次提交 有时执行了git commit -m \u0026quot;XXX\u0026quot;后，发现还有一些文件没有添加到暂存区，想撤回刚刚的提交操作，可以使用以下命令修改最后一次的提交信息\n git commit -amend    查看历史\n git log # 查看text.c文件的所有改动历史， # 每条记录显示在一行 git log --pretty=oneline test.c    恢复单个文件历史版本\n # 得到text.c的历史版本号 git log text.c # 恢复到版本为2e17053b时候的text.c文件 git reset 2e17053b    查看你曾使用过的git命令 git reflog用来记录你的每一次命令\n  git分支相关   推送远程分支\n git push \u0026lt;远程主机名\u0026gt; \u0026lt;本地分支名\u0026gt;:\u0026lt;远程分支名\u0026gt; git push origin local:remote # 示例 git push origin master # 表示将本地的master分支推送到远程的origin主线的master分支 # 如果master不存在，则会被新建    创建新的分支并切换\n git checkout -b \u0026lt;本地分支名\u0026gt; \u0026lt;远程分支名\u0026gt; # 示例： git checkout -b dev origin/master # 从远程拉取dev分支到本地,命名为develop，并切换到develop分支 git checkout -b develop origin/dev    删除分支\n # 删除远程分支 git push origin :\u0026lt;远程分支名\u0026gt; git push origin :dev # 等同于 git push origin --delete \u0026lt;远程分支名\u0026gt; # 删除本地分支 git branch -D \u0026lt;本地分支\u0026gt;    查看各个分支最后一个提交对象的信息\n git branch -v    查看与当前分支 合并/未合并 的分支\n # 与当前分支已经合并的分支 git branch --merged # 与当前分支未合并的分支 git branch --no-merged    同步远程服务器数据到本地\n git fetch origin    对于git pull的理解\n  git pull的过程可以理解为：\n git fetch origin master git merge FETCH_HEAD # 完整的格式为： git pull \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt; # 如果远程分支是与当前分支合并，则冒号后面的部分可以省略，例如： git pull origin dev  分支的合并  把一个分支整合到另一个分支有两种方法：merge和rebase（衍合） merge是把两个分支最新的快照和二者最新的共同祖先进行三方合并，产生一个新的提交对象。 rebase单独写\ngit stash缓存本地仓库工作目录   执行存储时，添加备注，方便查找，只有git stash也可以的，但查找时不方便。\n git stash save \u0026quot;save message\u0026quot;    查看stash了哪些存储\n git stash list    显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}。\n git stash show # 显示第二个存储改动 git stash show stash@{1}    显示存储的改动，默认显示第一个。\ngit stash show -p git stash show stash@{$num} -p # 显示第二个存储的改动 git stash show stash@{1} -p    应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储。\n git stash apply git stash apply stash@{$num} # 应用第二个 git stash apply stash@{1}    命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下，默认为第一个stash。\n git stash pop git stash pop stash@{$num} # 应用并删除第二个 git stash pop stash@{1}    丢弃stash@{$num}存储，从列表中删除这个存储\n git stash drop stash@{$num}    删除所有缓存的stash\n git stash clear    git submodule相关  添加第三方git仓库  1 2 3 4  # path是该子模块存储的目录路径 git submodule add \u0026lt;url\u0026gt; \u0026lt;path\u0026gt; # 例子 git submodule add https://XXXXXXX.git /home/user   添加完成后会在.gitmodules中看到每个submodule的信息。\n将第三方git仓库同步到主线  克隆仓库后，默认子模块的目录下是空的，需要在本地仓库根目录把子模块拉到本地，用到命令如下：\n1 2 3 4 5 6 7 8 9 10  git submodule init git submodule update 或者： git submodule update # 例子 git clone https://XXXXXXX.git git submodule init \u0026amp;\u0026amp; git submodule update #下面这句的效果和上面的命令效果一样 git clone https://XXXXXXX.git --recursive   删除submodule  1  git submodule deinit \u0026lt;submodule-name\u0026gt;    FAQs  执行 git remote add [shortname] [url] 如果提示：remote origin already exists.  则先删除：git remote rm origin 然后再添加：git remote add origin https://XXXX.git\n git add 操作时，有时会误添加一些不想提交的文件，如何解决？ 误add单个文件\n git reset HEAD 将file退回到unstage区    误add多个文件，只撤销部分文件\n git reset HEAD 将file退回到unstage区  windows git bash 在使用git log时中文乱码  执行命令export LANG=”zh_CN.UTF-8就好了\n","permalink":"https://newdivide2014.github.io/zh-cn/posts/git-cmd/","summary":"\u003cp\u003e记录一些常用的git命令，忘记的时候来翻翻看。\u003c/p\u003e","title":"git常用命令"},{"content":"2021年计划  养只可爱的小猫咪（这个可能实现不了啊，因为放假了怎么办还没想好） 学会网球🎾  ","permalink":"https://newdivide2014.github.io/about/","summary":"2021年计划  养只可爱的小猫咪（这个可能实现不了啊，因为放假了怎么办还没想好） 学会网球🎾  ","title":"关于我"},{"content":"我可能是得了主题病阿！一天换了十几个主题～换的我是真的好累啊。。。 已经被炸干了。。。 好累～🐶\n把主题又换成了papermod。。。\n","permalink":"https://newdivide2014.github.io/zh-cn/posts/change-theme/","summary":"我可能是得了主题病阿！一天换了十几个主题～换的我是真的好累啊。。。 已经被炸干了。。。 好累～🐶\n把主题又换成了papermod。。。","title":"沉迷换肤"}]